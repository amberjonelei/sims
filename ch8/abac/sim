
//given Main function
//set function on type (method/class)
func (ss *Sim) main(){
    ss.New()
	ss.Config()

	ss.Init()
	win := ss.ConfigGui()
	win.StartEventLoop()

    ss.newTrain()
}

//train for 50 runs 
func (ss *Sim) newTrain() {

	ss.Init()
	i := 1

    type set func(ss *Sim, x float64)
    set := setInhib
    parameter int := Inhibition
    start float64 := 0;
    end float64 := 0;
    incr float64 := 0;
    numSeeds int := 1;
    numTraining int := 5


    //which parameter
    //range and increment

    switch parameter; {
    case Inhibition:
        set := setInhib
    case InitialWeight:
        set := setInitWt
    case Context:
        set := setContext
    case XCal:
        set := setXCAL
    case LearningRate:
        set := Lrate
    }

    for k := 0; k < numSeeds; k++ {
        ss.newRndSeed()
        for i := start; i <= end; i += incr {
            set(ss, i)
            ss.init()
            for j := 0; j < numTraining; j++ {
                ss.Train()
            }
        }
    }
}

const (

    Inhibition int = Itoa
    InitialWeight
    Context
    XCal
    LearningRate
)

//bindata.go reads input files
//abac.go configure gui and nn
//abac.py uses leabra go emer

//set functions
//might have ti put in abac.go
func (ss *Sim, x float64) setInhib{
	ss.HiddenInhibGi = x
}

func (ss *Sim, x float64) setInitWt{
	ss.WtInitVar = x
}

func (ss *Sim, x float64) setContext{
	ss.FmContext = x
}

func (ss *Sim, x float64) setXCAL{
	ss.XCalLLrn = x
}

func (ss *Sim, x float64) setLrate{
	ss.Lrate = x
}

//chris psuedo
func run_simulation(model, data, parms) {
    model.New()
    // pass the parameters here or somewhere else to set them
    // maybe we can use a hashmap of parameters so that it is variable length
    // and the parameter values can be binded the model object via keyword?
    model.Config(parms)//doesnt take params use set
    // formerly CmdArgs
    model.setupAndRun()
    data.appendData(model)
}

func main(){

    // initialize model
    // initialize parameters
    // initialize data 
    // loop through parameters
    for parm in parms { 
        run_simulation(model, data, parms)    
    }
    return data 
}



//init weights function take out
func (nt *Network) InitWts() {
	nt.WtBalCtr = 0
	for _, ly := range nt.Layers {
		if ly.IsOff() {
			continue
		}
		ly.(LeabraLayer).InitWts()
	}
	// separate pass to enforce symmetry
	// st := time.Now()
	for _, ly := range nt.Layers {
		if ly.IsOff() {
			continue
		}
		ly.(LeabraLayer).InitWtSym()
	}
	// dur := time.Now().Sub(st)
	// fmt.Printf("sym: %v\n", dur)
}



//input version 

func (ss *Sim) newTrain() {

	ss.Init()
	i := 1

    parameter int := Inhibition
    int := x
    fmt.printf("Choose a variable to alter: \n")
    fmt.printf("(1)Inhibition  (2)Initial Weights  (3)Context  (4)XCAL Learning  (5)Learning Rate\n")
    fmt.scanf("%d", &x)

    parameter = x - 1
    type set func(ss *Sim, x float64)
    set := setInhib

    start float64 := 0;
    end float64 := 0;
    incr float64 := 0;
    numSeeds int := 1;
    numTraining int := 5

    fmt.printf("Choose a start value:\n")
    fmt.scanf("%f", &start)
    for start < 0 {
        fmt.printf("Choose start value greater than or equal to 0\n")
        fmt.scanf("%f", &start)
    }

    fmt.printf("Choose an end value:\n")
    fmt.scanf("%f", &end)
    for end < start {
        fmt.printf("Choose end value greater than start\n")
        fmt.scanf("%f", &end)
    }

    fmt.printf("Choose an increment value:\n")
    fmt.scanf("%f", &incr)
    for incr <= 0 {
        fmt.printf("Choose increment value greater than 0\n")
        fmt.scanf("%f", &incr)
    }

    fmt.printf("How many times do you want to train for each value?\n")
    fmt.scanf("%d", &numTraining)
    for numTraining <= 0 {
        fmt.printf("Choose training amount value greater than 0\n")
        fmt.scanf("%d", &incr)
    }

    fmt.printf("How many seeds do you want to use?\n")
    fmt.scanf("%d", &seeds)
    for numTraining <= 0 {
        fmt.printf("Choose seed amount value greater than 0\n")
        fmt.scanf("%d", &incr)
    }

    fmt.printf("Ready to Train\n")

    //which parameter
    //range and increment

    switch parameter; {
    case Inhibition:
        set := setInhib
    case InitialWeight:
        set := setInitWt
    case Context:
        set := setContext
    case XCal:
        set := setXCAL
    case LearningRate:
        set := Lrate
    }

    for k := 0; k < numSeeds; k++ {
        ss.newRndSeed()
        for i := start; i <= end; i += incr {
            set(ss, i)
            ss.init()
            for j := 0; j < numTraining; j++ {
                ss.Train()
            }
        }
    }
}




func (ss *Sim) newTrain() {

	ss.Init()
	
    parameters int := 0

    fmt.printf("How many parameters do you want to train?\n")
    fmt.printf("Choose integer between 1 and 5:\n")
    fmt.scanf("%f", &parameters)

    //use vector to store start/end/incr values and train after
    for l := 0; l < parameters; l++ {

        parameter int := Inhibition
        int := x
        fmt.printf("Choose a variable to alter: \n")
        fmt.printf("(1)Inhibition  (2)Initial Weights  (3)Context  (4)XCAL Learning  (5)Learning Rate\n")
        fmt.scanf("%d", &x)

        parameter = x - 1
        type set func(ss *Sim, x float64)
        set := setInhib

        start float64 := 0;
        end float64 := 0;
        incr float64 := 0;
        numSeeds int := 1;
        numTraining int := 5

        fmt.printf("Choose a start value:\n")
        fmt.scanf("%f", &start)
        for start < 0 {
            fmt.printf("Choose start value greater than or equal to 0\n")
            fmt.scanf("%f", &start)
        }

        fmt.printf("Choose an end value:\n")
        fmt.scanf("%f", &end)
        for end < start {
            fmt.printf("Choose end value greater than start\n")
            fmt.scanf("%f", &end)
        }

        fmt.printf("Choose an increment value:\n")
        fmt.scanf("%f", &incr)
        for incr <= 0 {
            fmt.printf("Choose increment value greater than 0\n")
            fmt.scanf("%f", &incr)
        }

        fmt.printf("How many times do you want to train for each value?\n")
        fmt.scanf("%d", &numTraining)
        for numTraining <= 0 {
            fmt.printf("Choose training amount value greater than 0\n")
            fmt.scanf("%d", &incr)
        }

        fmt.printf("How many seeds do you want to use?\n")
        fmt.scanf("%d", &seeds)
        for numTraining <= 0 {
            fmt.printf("Choose seed amount value greater than 0\n")
            fmt.scanf("%d", &incr)
        }

        fmt.printf("Ready to Train\n")

        //which parameter
        //range and increment

        switch parameter; {
        case Inhibition:
            set := setInhib
        case InitialWeight:
            set := setInitWt
        case Context:
            set := setContext
        case XCal:
            set := setXCAL
        case LearningRate:
            set := Lrate
        }

        for k := 0; k < numSeeds; k++ {
            ss.newRndSeed()
            for i := start; i <= end; i += incr {
                set(ss, i)
                ss.init()
                for j := 0; j < numTraining; j++ {
                    ss.Train()
                }
            }
        }
    }
}